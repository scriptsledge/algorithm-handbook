---
title: 0704. Binary Search
tags:
  - Easy
  - Binary Search
  - Recursion
---

# 0704. Binary Search

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/woWmBQDRbfY){{ .md-button }}

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0704){{ .md-button }}

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/binary-search/solutions/7463472/c-recursive-binary-search-olog-n-clean-e-cqo8){{ .md-button }}

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.

    You must write an algorithm with $O(\log n)$ runtime complexity.

### Examples

**Example 1:**
**Input:** `nums = [-1,0,3,5,9,12]`, `target = 9`
**Output:** `4`
**Explanation:** `9` exists in `nums` and its index is `4`

**Example 2:**
**Input:** `nums = [-1,0,3,5,9,12]`, `target = 2`
**Output:** `-1`
**Explanation:** `2` does not exist in `nums` so return `-1`

### Constraints

*   `1 <= nums.length <= 10^4`
*   `-10^4 < nums[i], target < 10^4`
*   All the integers in `nums` are unique.
*   `nums` is sorted in ascending order.

## üß† Intuition

Binary search is the most efficient way to search in a sorted collection. By repeatedly halving the search space, we can find any element (or determine its absence) in logarithmic time.

## üí° Approach

1.  **Divide:** Calculate the middle index `mid`. To prevent integer overflow, use `mid = low + (high - low) / 2`.
2.  **Conquer:**
    *   If `nums[mid] == target`, we've found the target.
    *   If `nums[mid] > target`, the target must be in the left half. Recurse on `[low, mid - 1]`.
    *   If `nums[mid] < target`, the target must be in the right half. Recurse on `[mid + 1, high]`.
3.  **Base Case:** If `low > high`, the search range is empty, and the target is not in the array.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0704/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(\log N)$
    The search space is halved at each step, leading to a logarithmic number of comparisons.

*   **Space Complexity:** $O(\log N)$
    Since we are using a recursive implementation, the recursion stack will consume $O(\log N)$ space. An iterative approach would reduce this to $O(1)$.