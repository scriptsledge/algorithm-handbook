---
title: 1. Two Sum
tags:
  - Array
  - Hash Table
  - Easy
---

# 1. Two Sum

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/vuQXdeAL43A){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0001){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/two-sum/solutions/7463092/c-hash-map-on-time-on-space-clean-effici-0l1d){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.

    You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

    You can return the answer in any order.

### Examples

**Example 1:**
```text
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**
```text
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:**
```text
Input: nums = [3,3], target = 6
Output: [0,1]
```

### Constraints
*   `2 <= nums.length <= 10^4`
*   `-10^9 <= nums[i] <= 10^9`
*   `-10^9 <= target <= 10^9`
*   **Only one valid answer exists.**

## üß† Intuition

The naive approach is to use nested loops to check every pair of numbers, which takes $O(N^2)$ time.

However, we can optimize this by using a **Hash Table**. As we iterate through the array, we check if the **complement** (i.e., `target - current_number`) exists in our table. If it does, we've found our pair. If not, we add the current number to the table and move on. This allows us to find the answer in a single pass.

## üí° Approach

1.  Create an empty hash map to store `value -> index`.
2.  Iterate through the array `nums`:
    *   Calculate `complement = target - nums[i]`.
    *   Check if `complement` exists in the hash map.
    *   If it exists, return `{hashMap[complement], i}`.
    *   If it doesn't exist, store `nums[i]` and its index `i` in the hash map.
3.  Since the problem guarantees a solution, we will always find a match.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0001/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(N)$
    *   We traverse the array once. Hash map lookups and insertions are $O(1)$ on average.

*   **Space Complexity:** $O(N)$
    *   In the worst case, we store $N$ elements in the hash map.