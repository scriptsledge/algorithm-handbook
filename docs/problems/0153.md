---
title: 0153. Find Minimum in Rotated Sorted Array
tags:
  - Binary Search
  - Array
  - Medium
---

# 0153. Find Minimum in Rotated Sorted Array

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/vkfP6mTvT_0){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0153){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:

    - `[4,5,6,7,0,1,2]` if it was rotated 4 times.
    - `[0,1,2,4,5,6,7]` if it was rotated 7 times.

    Notice that rotating an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

    Given the sorted rotated array `nums` of unique elements, return the *minimum element* of this array.

    You must write an algorithm that runs in `O(log n)` time.

### Examples

**Example 1:**
Input: `nums = [3,4,5,1,2]`
Output: `1`
Explanation: The original array was `[1,2,3,4,5]` rotated 3 times.

**Example 2:**
Input: `nums = [4,5,6,7,0,1,2]`
Output: `0`
Explanation: The original array was `[0,1,2,4,5,6,7]` and it was rotated 4 times.

**Example 3:**
Input: `nums = [11,13,15,17]`
Output: `11`
Explanation: The original array was `[11,13,15,17]` and it was rotated 4 times.

### Constraints

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- All the integers of `nums` are unique.
- `nums` is sorted and rotated between `1` and `n` times.

## üß† Intuition

In a sorted array, the minimum element is at index 0. When it is rotated, it is no longer at index 0, but the array is still composed of two sorted parts. Binary search can be used because in any range `[low, high]`, at least one of the halves `[low, mid]` or `[mid, high]` will be sorted.

## üí° Approach

1.  Initialize `low = 0`, `high = n - 1`, and `minEle = INT_MAX`.
2.  Perform Binary Search:
    -   Calculate `mid`.
    -   Check which side is sorted:
        -   If `nums[mid] <= nums[high]`: The right side is sorted. The minimum value in this range is `nums[mid]`. Update `minEle` and search the left side (`high = mid - 1`).
        -   Else: The left side is sorted. The minimum value in this range is `nums[low]`. Update `minEle` and search the right side (`low = mid + 1`).
3.  The `minEle` will hold the global minimum.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0153/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(\log N)$
    We are using binary search, which divides the search space by half in each iteration.

*   **Space Complexity:** $O(1)$
    We only use a few variables for tracking indices and the minimum element.