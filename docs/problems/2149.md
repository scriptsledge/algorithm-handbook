---
title: 2149. Rearrange Array Elements by Sign
tags:
  - Array
  - Two Pointers
  - Medium
---

# 2149. Rearrange Array Elements by Sign

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Short](https://youtube.com/shorts/c-BjOSH3xms){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/2149){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [My Post](https://leetcode.com/problems/rearrange-array-elements-by-sign/solutions/7455816/c-on-time-two-pointers-clean-intuitive-s-xsav){ .md-button }

</div>

## ðŸ§  Intuition

The core constraint is preserving the **relative order** of positive and negative numbers separately. This immediately suggests that we can't swap elements in place arbitrarily. We need to "pick" the next positive number and the next negative number in their original sequences.

Since the output must alternate `[+, -, +, -, ...]`, we know exactly where each number goes:
*   Positive numbers go to indices `0, 2, 4, ...`
*   Negative numbers go to indices `1, 3, 5, ...`

## ðŸ’¡ Approach: Two Pointers (Optimal)

We can achieve this in a single pass using two pointers and a result array.

1.  **Initialize**:
    *   `pos` pointer at `0` (first even index).
    *   `neg` pointer at `1` (first odd index).
    *   A `result` vector of the same size as input.
2.  **Iterate**: Loop through every number `x` in the input array.
3.  **Place**:
    *   If `x > 0`: Place `x` at `result[pos]`, then advance `pos` by 2.
    *   If `x < 0`: Place `x` at `result[neg]`, then advance `neg` by 2.

## ðŸ’» Code

=== "C++"

    ```cpp
    --8<-- "src/2149/solution.cpp"
    ```

## ðŸ“Š Complexity Analysis

*   **Time Complexity:** $O(N)$
    We iterate through the array exactly once. Each insertion is an $O(1)$ operation.

*   **Space Complexity:** $O(N)$
    We use an extra array `result` of size $N$ to store the rearranged elements.
    *(Note: Modifying the array in-place while keeping stability usually requires $O(N^2)$ time or complex rotation logic, so $O(N)$ space is standard for the optimal linear time solution.)*
