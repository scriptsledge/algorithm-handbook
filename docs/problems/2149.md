---
title: 2149. Rearrange Array Elements by Sign
tags:
  - Array
  - Two Pointers
  - Medium
---

# 2149. Rearrange Array Elements by Sign

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Short](https://youtube.com/shorts/c-BjOSH3xms){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/2149){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [My Post](https://leetcode.com/problems/rearrange-array-elements-by-sign/solutions/7455816/c-on-time-two-pointers-clean-intuitive-s-xsav){ .md-button }

</div>

## ðŸ“ Problem Description

!!! info "Problem Statement"
    You are given a **0-indexed** integer array `nums` of **even** length consisting of an **equal** number of positive and negative integers.

    You should return the array of `nums` such that the array follows the given conditions:
    1. Every consecutive pair of integers have opposite signs.
    2. For all integers with the same sign, the order in which they were present in `nums` is preserved.
    3. The rearranged array begins with a positive integer.

    Return *the modified array after rearranging the elements to satisfy the aforementioned conditions*.

### Examples

**Example 1:**
> **Input:** `nums = [3,1,-2,-5,2,-4]`
> **Output:** `[3,-2,1,-5,2,-4]`

**Example 2:**
> **Input:** `nums = [-1,1]`
> **Output:** `[1,-1]`

### Constraints
* `2 <= nums.length <= 2 * 10^5`
* `nums.length` is even
* `1 <= |nums[i]| <= 10^5`

## ðŸ§  Intuition

The core constraint is preserving the **relative order** of positive and negative numbers separately. This immediately suggests that we can't swap elements in place arbitrarily. We need to "pick" the next positive number and the next negative number in their original sequences.

Since the output must alternate `[+, -, +, -, ...]`, we know exactly where each number goes:
*   Positive numbers go to indices `0, 2, 4, ...`
*   Negative numbers go to indices `1, 3, 5, ...`

## ðŸ’¡ Approach: Two Pointers (Optimal)

We can achieve this in a single pass using two pointers and a result array.

1.  **Initialize**:
    *   `pos` pointer at `0` (first even index).
    *   `neg` pointer at `1` (first odd index).
    *   A `result` vector of the same size as input.
2.  **Iterate**: Loop through every number `x` in the input array.
3.  **Place**:
    *   If `x > 0`: Place `x` at `result[pos]`, then advance `pos` by 2.
    *   If `x < 0`: Place `x` at `result[neg]`, then advance `neg` by 2.

## ðŸ’» Code

=== "C++"

    ```cpp
    --8<-- "src/2149/solution.cpp"
    ```

## ðŸ“Š Complexity Analysis

*   **Time Complexity:** $O(N)$
    We iterate through the array exactly once. Each insertion is an $O(1)$ operation.

*   **Space Complexity:** $O(N)$
    We use an extra array `result` of size $N$ to store the rearranged elements.