---
title: 88. Merge Sorted Array
tags:
  - Array
  - Two Pointers
  - Sorting
  - Easy
---

# 88. Merge Sorted Array

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/MSFm9bfnE0c){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0088){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/merge-sorted-array/solutions/7462867/c-two-pointers-reverse-omn-time-o1-space-whou){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

    **Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.

    The final sorted array should not be returned by the function, but instead be stored inside the array `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.

### Examples

**Example 1:**
```text
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
```

**Example 2:**
```text
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
```

**Example 3:**
```text
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
```

### Constraints
*   `nums1.length == m + n`
*   `nums2.length == n`
*   `0 <= m, n <= 200`
*   `1 <= m + n <= 200`
*   `-10^9 <= nums1[i], nums2[j] <= 10^9`

## üß† Intuition

We have two sorted arrays, and we want to merge them into the first one (`nums1`). `nums1` has extra zeros at the end to fit everything.

If we start from the beginning (index 0), every time we want to insert an element from `nums2` into `nums1`, we would have to shift all subsequent elements of `nums1` to the right. This shifting is expensive ($O(N)$ per insertion).

However, we know exactly where the final sorted array ends (at index `m + n - 1`). Since the end of `nums1` is empty (buffer space), we can fill the array **backwards**. This ensures we never overwrite a value in `nums1` that we haven't processed yet.

## üí° Approach

1.  Initialize three pointers:
    *   `p1` pointing to the last actual element in `nums1` (`m - 1`).
    *   `p2` pointing to the last element in `nums2` (`n - 1`).
    *   `p` pointing to the last position in the buffer (`m + n - 1`).
2.  Iterate while both `p1` and `p2` are valid ($\ge 0$):
    *   Compare `nums1[p1]` and `nums2[p2]`.
    *   Place the larger value at `nums1[p]`.
    *   Decrement `p` and the pointer of the chosen element.
3.  **Edge Case:** If `nums2` still has elements left after `p1` runs out (meaning `nums2` had smaller elements than everything in `nums1`), copy the remaining `nums2` elements into the front of `nums1`.
4.  If `p1` has elements left, we don't need to do anything because they are already in place.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0088/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(M + N)$
    *   We traverse both arrays once from back to front.

*   **Space Complexity:** $O(1)$
    *   We assume `nums1` has allocated space. We do not use any extra data structures.