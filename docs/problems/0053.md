---
title: 53. Maximum Subarray
tags:
  - Array
  - Divide and Conquer
  - Dynamic Programming
  - Medium
---

# 53. Maximum Subarray

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/ujSbHn855So){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0053){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/maximum-subarray/solutions/7462121/c-kadanes-algorithm-on-time-o1-space-sim-lcb1){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given an integer array `nums`, find the **subarray** with the largest sum, and return *its sum*.

### Examples

**Example 1:**
```text
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
```

**Example 2:**
```text
Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
```

**Example 3:**
```text
Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
```

### Constraints
*   `1 <= nums.length <= 10^5`
*   `-10^4 <= nums[i] <= 10^4`

## üß† Intuition

The naive approach is to check every possible subarray (all possible start and end indices), calculate their sums, and find the maximum. However, with $N$ up to $10^5$, an $O(N^2)$ solution will result in Time Limit Exceeded (TLE). We need a linear time $O(N)$ solution.

The key observation is: **Should we extend the current subarray or start a new one?**
If the sum of the current subarray becomes negative, it essentially becomes a "burden" to any future element. No matter what the next number is, adding it to a negative sum will result in a smaller value than just starting fresh with the next number alone.

## üí° Approach

We use **Kadane's Algorithm**, which is a dynamic programming / greedy approach:

1.  Initialize `current_sum = 0` and `max_sum = nums[0]`.
2.  Iterate through each number `num` in `nums`.
3.  Add `num` to `current_sum`.
4.  Update `max_sum` if `current_sum` is greater.
5.  If `current_sum` becomes negative, reset it to `0`. This effectively discards the current subarray and starts a new one from the next element.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0053/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(N)$
    *   We iterate through the array exactly once.

*   **Space Complexity:** $O(1)$
    *   We only use two variables (`current_sum` and `max_sum`) for storage.