---
title: 2563. Count the Number of Fair Pairs
tags:
  - Array
  - Two Pointers
  - Binary Search
  - Sorting
  - Medium
---

# 2563. Count the Number of Fair Pairs

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/v0hsuMQVeBk){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/2563){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/count-the-number-of-fair-pairs/solutions/){ .md-button }

</div>

## ğŸ“ Problem Description

!!! info "Problem Statement"
    Given a 0-indexed integer array `nums` of size `n` and two integers `lower` and `upper`, return the number of fair pairs.

    A pair `(i, j)` is fair if:
    - `0 <= i < j < n`, and
    - `lower <= nums[i] + nums[j] <= upper`

### Examples

**Example 1:**
```text
Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6
Output: 6
Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).
```

**Example 2:**
```text
Input: nums = [1,7,9,2,5], lower = 11, upper = 11
Output: 1
Explanation: There is a single fair pair: (2,3).
```

### Constraints
*   `1 <= nums.length <= 10^5`
*   `nums.length == n`
*   `-10^9 <= nums[i] <= 10^9`
*   `-10^9 <= lower <= upper <= 10^9`

## ğŸ§  Intuition

The problem asks us to count pairs `(i, j)` with `i < j` whose sum falls within a specific range `[lower, upper]`. A brute-force approach would check all $O(N^2)$ pairs, which is too slow for $N = 10^5$.

Since the order of elements in a pair doesn't matter for the sum, and the condition `i < j` just means we need to pick two distinct elements, we can **sort** the array. Sorting allows us to use efficient search techniques like binary search or two pointers.

## ğŸ’¡ Approach

1.  **Sort the array** `nums`.
2.  Iterate through each element `nums[i]` from `0` to `n-1`.
3.  For each `nums[i]`, we need to find the number of elements `nums[j]` where `j > i` such that `lower <= nums[i] + nums[j] <= upper`.
4.  This is equivalent to finding `j > i` such that `lower - nums[i] <= nums[j] <= upper - nums[i]`.
5.  We can use binary search to find the range of valid `j`'s:
    *   `lb = lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i])` gives the first index `j > i` where `nums[j]` is at least `lower - nums[i]`.
    *   `ub = upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i])` gives the first index `j > i` where `nums[j]` is strictly greater than `upper - nums[i]`.
6.  The number of valid `j`'s for a fixed `i` is `ub - lb`.
7.  Sum these counts for all `i`.

## ğŸ’» Code

=== "C++"

    ```cpp
    --8<-- "src/2563/solution.cpp"
    ```

## ğŸ“Š Complexity Analysis

*   **Time Complexity:** $O(N \log N)$
    *   Sorting takes $O(N \log N)$.
    *   Iterating through the array takes $O(N)$, and for each element, we perform two binary searches, each taking $O(\log N)$.
    *   Total: $O(N \log N) + O(N \log N) = O(N \log N)$.

*   **Space Complexity:** $O(1)$ (ignoring the space used by the sorting algorithm).
    *   We only use a few extra variables for counting and iterators.