---
title: 56. Merge Intervals
tags:
  - Array
  - Sorting
  - Medium
---

# 56. Merge Intervals

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/FkppnZQVxyk){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0056){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/merge-intervals/solutions/7462636/c-sorting-merging-on-log-n-clean-easy-to-glht){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.

### Examples

**Example 1:**
```text
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**
```text
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Example 3:**
```text
Input: intervals = [[4,7],[1,4]]
Output: [[1,7]]
Explanation: Intervals [1,4] and [4,7] are considered overlapping.
```

### Constraints
*   `1 <= intervals.length <= 10^4`
*   `intervals[i].length == 2`
*   `0 <= start_i <= end_i <= 10^4`

## üß† Intuition

The core difficulty is that intervals can come in any order. Comparing every interval with every other interval to check for overlaps would take $O(N^2)$ time.

However, if we **sort** the intervals by their start times, overlapping intervals will always be adjacent to each other. This allows us to process the intervals linearly. We can simply maintain a "current" interval and try to merge subsequent intervals into it.

## üí° Approach

1.  **Sort:** Sort the `intervals` array based on the start time of each interval.
2.  **Initialize:** Create a `result` list. Add the first interval to it as the "current merged interval".
3.  **Iterate:** Loop through the remaining intervals:
    *   Let the last added interval in `result` be `[lastStart, lastEnd]`.
    *   Let the current interval being examined be `[currentStart, currentEnd]`.
    *   **If Overlap (`currentStart <= lastEnd`):** The intervals merge. Update the end time of the last interval: `lastEnd = max(lastEnd, currentEnd)`.
    *   **If No Overlap:** The overlap chain is broken. Add `[currentStart, currentEnd]` to `result`.
4.  **Return:** The `result` list now contains the merged intervals.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0056/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(N \log N)$
    *   Sorting the intervals takes $O(N \log N)$.
    *   The linear pass takes $O(N)$.
    *   Total complexity is dominated by sorting.

*   **Space Complexity:** $O(N)$
    *   We create a `result` array which, in the worst case (no overlaps), stores all $N$ intervals.
    *   If we disregard the output space, the sorting algorithm takes $O(\log N)$ or $O(N)$ auxiliary space depending on implementation.