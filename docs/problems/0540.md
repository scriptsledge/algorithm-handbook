---
title: 540. Single Element in a Sorted Array
tags:
  - Array
  - Binary Search
  - Medium
---

# 540. Single Element in a Sorted Array

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/KUj96Ovg6bU){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0540){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/7511594/olog-n-binary-search-even-index-pattern-4c8r5){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.

    Return the single element that appears only once.

    Your solution must run in $O(\log n)$ time and $O(1)$ space.

### Examples

**Example 1:**
```text
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
```

**Example 2:**
```text
Input: nums = [3,3,7,7,10,11,11]
Output: 10
```

### Constraints
*   `1 <= nums.length <= 10^5`
*   `0 <= nums[i] <= 10^5`

## üß† Intuition

In a sorted array where every element except one appears twice, the array length is always odd. If we look at the indices of pairs:
- Before the single element: Pairs start at **even** indices $(0,1), (2,3), (4,5) \dots$
- After the single element: Pairs start at **odd** indices $(1,2), (3,4), (5,6) \dots$

This observation allows us to use binary search to find the point where this pattern breaks.

## üí° Approach

1.  Use binary search with `low = 0` and `high = n - 1`.
2.  In each step, find `mid`.
3.  Ensure we are looking at an **even index** to start our comparison. If `mid` is odd, we decrement it by 1.
4.  Check if `nums[mid]` is the same as its neighbor `nums[mid + 1]`:
    *   **If `nums[mid] == nums[mid + 1]`**: The pattern is still correct (pairs starting at even indices). The single element must be in the **right half**. Set `low = mid + 2`.
    *   **If `nums[mid] != nums[mid + 1]`**: The pattern has broken. The single element is either at `mid` or in the **left half**. Set `high = mid`.
5.  When `low == high`, we have found the single element.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0540/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(\log N)$
    *   We use binary search, reducing the search space by half in each iteration.

*   **Space Complexity:** $O(1)$
    *   We only use a few integer variables for pointers.