---
title: 162. Find Peak Element
tags:
  - Array
  - Binary Search
  - Medium
---

# 162. Find Peak Element

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/__cbZP0ms3E){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0162){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/find-peak-element/solutions/7511616/olog-n-binary-search-slope-analysis-visu-hiv5){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    A peak element is an element that is strictly greater than its neighbors.

    Given a 0-indexed integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

    You may imagine that `nums[-1] = nums[n] = -‚àû`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

    You must write an algorithm that runs in $O(\log n)$ time.

### Examples

**Example 1:**
```text
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
```

**Example 2:**
```text
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
```

### Constraints
*   `1 <= nums.length <= 1000`
*   `-2^31 <= nums[i] <= 2^31 - 1`
*   `nums[i] != nums[i + 1]` for all valid `i`.

## üß† Intuition

The problem asks for any peak element in $O(\log n)$ time. This strongly suggests binary search. Even though the array isn't sorted, we can use the relative slopes between adjacent elements to navigate toward a peak. If an element is increasing relative to its right neighbor, we are on an "uphill" slope, and a peak must exist somewhere ahead.

## üí° Approach

1.  Initialize `low = 0` and `high = n - 1`.
2.  While `low < high`:
    *   Find the middle index `mid`.
    *   Compare `nums[mid]` with `nums[mid + 1]`.
    *   **If `nums[mid] < nums[mid + 1]`**: We are in an ascending sequence. There must be a peak to the right of `mid`. Set `low = mid + 1`.
    *   **Else (`nums[mid] >= nums[mid + 1]`)**: We are in a descending sequence. There is a peak at `mid` or to its left. Set `high = mid`.
3.  The search converges when `low == high`, which is the index of a peak element.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0162/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(\log N)$
    *   We use standard binary search, halving the search space in each step.

*   **Space Complexity:** $O(1)$
    *   We only use two pointers and a few integer variables.