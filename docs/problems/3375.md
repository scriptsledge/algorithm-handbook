---
title: 3375. Minimum Operations to Make Array Values Equal to K
tags:
  - Array
  - Hash Table
  - Easy
---

# 3375. Minimum Operations to Make Array Values Equal to K

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/nh-EGn7PdYg){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/3375){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/minimum-operations-to-make-array-values-equal-to-k/solutions/7463192/c-unordered-set-on-time-on-space-simple-psse4){ .md-button }

</div>

## ðŸ“ Problem Description

!!! info "Problem Statement"
    You are given an integer array `nums` and an integer `k`.
    An integer `h` is called **valid** if all values in the array that are strictly greater than `h` are identical.
    You are allowed to perform the following operation on `nums`:
    1. Select an integer `h` that is **valid** for the current values in `nums`.
    2. For each index `i` where `nums[i] > h`, set `nums[i]` to `h`.

    Return the **minimum number of operations** required to make every element in `nums` equal to `k`. If it is impossible to make all elements equal to `k`, return `-1`.

### Examples

**Example 1:**
```text
Input: nums = [5,2,5,4,5], k = 2
Output: 2
Explanation: The operations can be performed in order using valid integers 4 and then 2.
```

**Example 2:**
```text
Input: nums = [2,1,2], k = 2
Output: -1
Explanation: It is impossible to make all the values equal to 2.
```

**Example 3:**
```text
Input: nums = [9,7,5,3], k = 1
Output: 4
```

### Constraints
*   `1 <= nums.length <= 100`
*   `1 <= nums[i] <= 100`
*   `1 <= k <= 100`

## ðŸ§  Intuition

The operation allows us to take all elements greater than a value $h$ and set them to $h$, but only if those elements are all **currently equal**. This "valid $h$" constraint implies that we must process the unique values in the array in descending order. We "sink" the current maximum unique value down to the level of the next unique value.

To reach the target value $k$:
1. If any number is already less than $k$, we can never reach $k$ because operations only decrease values.
2. Every unique value in the array that is strictly greater than $k$ must be reduced. Because of the "valid $h$" rule, each distinct value $> k$ requires exactly one operation to be brought down to the next level (and eventually to $k$).

## ðŸ’¡ Approach

1.  **Iterate through `nums`:**
    *   If any element `nums[i] < k`, return `-1` immediately.
    *   If `nums[i] > k`, add it to an `unordered_set`.
2.  **Count Unique Values:** The number of operations needed is the number of distinct values we need to "sink," which is the size of the set.

## ðŸ’» Code

=== "C++"

    ```cpp
    --8<-- "src/3375/solution.cpp"
    ```

## ðŸ“Š Complexity Analysis

*   **Time Complexity:** $O(N)$
    *   We traverse the array once to check values and populate the set.

*   **Space Complexity:** $O(N)$
    *   In the worst case where all elements are distinct and greater than $k$, the set will store $N$ elements.