---
title: 3392. Count Subarrays of Length Three With a Condition
tags:
  - Array
  - Easy
---

# 3392. Count Subarrays of Length Three With a Condition

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/mqfaMGXhPJY){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/3392){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/count-subarrays-of-length-three-with-a-condition/solutions/7504805/c-on-simple-window-check-3392-count-suba-j28v){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given an integer array `nums`, return the number of subarrays of length 3 such that the sum of the first and third numbers equals exactly half of the second number.

### Examples

**Example 1:**

```
Input: nums = [1,2,1,4,1]
Output: 1
```

**Example 2:**

```
Input: nums = [1,1,1]
Output: 0
```

### Constraints

*   `3 <= nums.length <= 100`
*   `-100 <= nums[i] <= 100`

## üß† Intuition

The problem asks us to count specific windows of size 3. Since the constraints are very small ($N \le 100$), a simple linear scan over all possible subarrays of length 3 is perfectly efficient.

## üí° Approach

1.  Initialize a `count` variable to 0.
2.  Iterate through the array with a loop index `i` from `0` up to `nums.size() - 3`.
3.  For each window `[nums[i], nums[i+1], nums[i+2]]`:
    *   Check if `nums[i] + nums[i+2]` is exactly half of `nums[i+1]`.
    *   **Optimization Tip:** To avoid floating-point division errors (e.g., if `nums[i+1]` is odd), use multiplication: `2 * (nums[i] + nums[i+2]) == nums[i+1]`.
4.  Increment `count` if the condition is met.
5.  Return the final `count`.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/3392/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(N)$ where $N$ is the length of the array. We visit each element a constant number of times.
    
*   **Space Complexity:** $O(1)$ as we only use a single counter variable.