---
title: 0075. Sort Colors
tags:
  - Array
  - Two Pointers
  - Sorting
  - Medium
---

# 0075. Sort Colors

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/Dq-waygVwz0){{ .md-button }}

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0075){{ .md-button }}

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/sort-colors/solutions/7531693/on-solution-three-pointers-dutch-nationa-833v){{ .md-button }}

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given an array `nums` with `n` objects colored red, white, or blue, sort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

    We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.

    You must solve this problem without using the library's sort function.

### Examples

**Example 1:**
- **Input:** `nums = [2,0,2,1,1,0]`
- **Output:** `[0,0,1,1,2,2]`

**Example 2:**
- **Input:** `nums = [2,0,1]`
- **Output:** `[0,1,2]`

### Constraints
- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` is either `0`, `1`, or `2`.

**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?

## üß† Intuition

The problem is a classic variation of the **Dutch National Flag problem**. Since there are only three possible values (0, 1, and 2), we can partition the array into three sections:
1. All 0s at the beginning.
2. All 1s in the middle.
3. All 2s at the end.

## üí° Approach

We use three pointers:
- `left`: Points to the position where the next `0` should be placed.
- `right`: Points to the position where the next `2` should be placed.
- `i`: Current element being inspected.

**Algorithm:**
1. Initialize `left = 0`, `right = n - 1`, and `i = 0`.
2. While `i <= right`:
    - If `nums[i] == 0`: Swap `nums[i]` with `nums[left]`, increment both `left` and `i`.
    - If `nums[i] == 2`: Swap `nums[i]` with `nums[right]`, decrement `right`. (Don't increment `i` yet because the swapped element needs to be checked).
    - If `nums[i] == 1`: Simply increment `i`.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0075/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(N)$
    We traverse the array at most once.

*   **Space Complexity:** $O(1)$
    We only use a constant amount of extra space for the three pointers.