---
title: 0035. Search Insert Position
tags:
  - Binary Search
  - Array
  - Easy
---

# 0035. Search Insert Position

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/4gcUIq43Hv4){{ .md-button }}

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0035){{ .md-button }}

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/search-insert-position/solutions/7488942/c-olog-n-solution-binary-search-clean-ef-o80x){{ .md-button }}

</div>

## ðŸ“ Problem Description

!!! info "Problem Statement"
    Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

    You must write an algorithm with $O(\log n)$ runtime complexity.

### Examples

**Example 1:**
> **Input:** `nums = [1,3,5,6]`, `target = 5`
> **Output:** `2`

**Example 2:**
> **Input:** `nums = [1,3,5,6]`, `target = 2`
> **Output:** `1`

**Example 3:**
> **Input:** `nums = [1,3,5,6]`, `target = 7`
> **Output:** `4`

### Constraints

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` contains distinct values sorted in ascending order.
- `-10^4 <= target <= 10^4`

## ðŸ§  Intuition

The array is already sorted, and the requirement for $O(\log n)$ complexity strongly suggests a **Binary Search** approach. We are looking for the smallest index `i` such that `nums[i] >= target`. This index will be:
1. The index of the target if it exists.
2. The index where the target should be inserted if it doesn't exist.

## ðŸ’¡ Approach

We can implement this using a standard binary search template:

1.  **Initialize:** Set `low = 0` and `high = nums.size() - 1`. Initialize `pos = nums.size()` to cover the case where the target is larger than all elements in the array.
2.  **Binary Search Loop:**
    -   Calculate `mid = low + (high - low) / 2`.
    -   If `nums[mid] >= target`:
        -   This `mid` index is a potential answer. Update `pos = mid`.
        -   Continue searching in the left half to see if there's an even smaller index that satisfies the condition: `high = mid - 1`.
    -   Else (`nums[mid] < target`):
        -   The target must be further to the right: `low = mid + 1`.
3.  **Return:** After the loop, `pos` will hold the correct index.

## ðŸ’» Code

=== "C++"

    ```cpp
    --8<-- "src/0035/solution.cpp"
    ```

## ðŸ“Š Complexity Analysis

*   **Time Complexity:** $O(\log N)$
    We divide the search space by half in each iteration.

*   **Space Complexity:** $O(1)$
    We only use a constant amount of extra space for pointers.