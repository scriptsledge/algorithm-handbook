---
title: 152. Maximum Product Subarray
tags:
  - Array
  - Dynamic Programming
  - Medium
---

# 152. Maximum Product Subarray

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/OI1irq3hDjE){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0152){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/maximum-product-subarray/solutions/7463331/c-two-pass-solution-on-time-o1-space-sim-x56m){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given an integer array `nums`, find a **subarray** that has the largest product, and return *the product*.

    The test cases are generated so that the answer will fit in a **32-bit** integer.

### Examples

**Example 1:**
```text
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

**Example 2:**
```text
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

### Constraints
*   `1 <= nums.length <= 2 * 10^4`
*   `-10 <= nums[i] <= 10`
*   The product of any subarray of `nums` is guaranteed to fit in a 32-bit integer.

## üß† Intuition

The "Maximum Product Subarray" problem is similar to "Maximum Sum Subarray" (Kadane's Algorithm), but with a twist: **negative numbers**.

*   If all numbers are positive, we simply multiply them all.
*   If we have a negative number, it flips the sign of the current product. A large positive product becomes a large negative one (which is bad for the max), but a large negative product becomes a large positive one (which is good).

This "sign flipping" means we can't simply discard negative results like we do in Kadane's algorithm.

**Key Observation:**
For any subarray not containing zero, the maximum product will always include either the **first element** or the **last element**.
*   If there are an **even** number of negatives, the product of the whole array is positive and maximal.
*   If there are an **odd** number of negatives, one negative number splits the array into two positive sections. We need to check the product "prefix" (before the splitter) and the "suffix" (after the splitter).

## üí° Approach

We can solve this efficiently with a **Two-Pass Scan**:

1.  **Forward Pass:** Iterate from left to right, maintaining a running product `fwd`. If we encounter a zero, reset `fwd` to 1. Track the maximum value of `fwd`.
2.  **Backward Pass:** Iterate from right to left, maintaining a running product `bwd`. If we encounter a zero, reset `bwd` to 1. Track the maximum value of `bwd`.

The global maximum of these two passes is our answer. This works because it effectively checks all prefixes and suffixes relative to the negative numbers and zeros.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0152/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(N)$
    *   We iterate through the array once (calculating forward and backward products in the same loop).

*   **Space Complexity:** $O(1)$
    *   We only use integer variables for tracking products.