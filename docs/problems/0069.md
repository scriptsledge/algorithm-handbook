---
title: 69. Sqrt(x)
tags:
  - Math
  - Binary Search
  - Easy
---

# 69. Sqrt(x)

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/e4VhcH_7DWE){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0069){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/sqrtx/solutions/){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given a non-negative integer `x`, return the square root of `x` rounded down to the nearest integer. The returned integer should be non-negative as well.

    You must not use any built-in exponent function or operator.

### Examples

**Example 1:**
```text
Input: x = 4
Output: 2
```

**Example 2:**
```text
Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.
```

### Constraints
*   `0 <= x <= 2^31 - 1`

## üß† Intuition

The square root function is monotonic. As $k$ increases, $k^2$ also increases. This monotonicity is the perfect condition for applying **Binary Search**. Instead of searching for an element in an array, we are searching for the largest integer $k$ in the range $[0, x]$ such that $k^2 \le x$.

## üí° Approach

1.  Handle the search range: `low = 0`, `high = x`.
2.  In each iteration:
    *   Calculate `mid`.
    *   Compute $mid^2$. **Crucial:** Use `long long` to prevent overflow, as `mid` can be up to $2^{31}-1$.
    *   If $mid^2 \le x$: This `mid` is a potential candidate. To find a possibly larger candidate, move the lower bound: `low = mid + 1`.
    *   If $mid^2 > x$: `mid` is too large. Move the upper bound: `high = mid - 1`.
3.  When the loop terminates, `high` will be the floor of the square root.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0069/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(\log X)$
    *   The search space $[0, x]$ is halved in each step.

*   **Space Complexity:** $O(1)$
    *   We only use a constant amount of extra space for the pointers.