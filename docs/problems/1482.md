---
title: 1482. Minimum Number of Days to Make m Bouquets
tags:
  - Array
  - Binary Search
  - Medium
---

# 1482. Minimum Number of Days to Make m Bouquets

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/K6E2-lh9lfk){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/1482){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/solutions/7511740/on-log-d-binary-search-answer-space-clea-e3a6){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    You are given an integer array `bloomDay`, an integer `m` and an integer `k`.

    You want to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent** flowers from the garden.

    The garden consists of `n` flowers, the `i`-th flower will bloom in the `bloomDay[i]` and then can be used in exactly one bouquet.

    Return the minimum number of days you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return `-1`.

### Examples

**Example 1:**
```text
Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
Output: 3
```

**Example 2:**
```text
Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
Output: -1
```

**Example 3:**
```text
Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
Output: 12
```

### Constraints
*   `bloomDay.length == n`
*   `1 <= n <= 10^5`
*   `1 <= bloomDay[i] <= 10^9`
*   `1 <= m <= 10^6`
*   `1 <= k <= n`

## üß† Intuition

This problem asks for a minimum threshold (days) to satisfy a condition. The more days we wait, the more flowers bloom, making it easier (or at least not harder) to form the required bouquets. This monotonicity is a key indicator for **Binary Search on Answer**.

## üí° Approach

1.  **Check Feasibility:** First, check if it's even possible to form `m` bouquets of `k` flowers each. If $m \times k > n$, return `-1`.
2.  **Binary Search on Days:**
    *   Set the search range for days: `low = min(bloomDay)` and `high = max(bloomDay)`.
    *   In each step, calculate `mid`.
    *   **Check Function (`isPossible`):**
        *   Iterate through the `bloomDay` array.
        *   Keep a counter of consecutive flowers that have bloomed within `mid` days.
        *   Whenever the counter reaches `k`, increment the bouquet count and reset the counter.
        *   If the flower hasn't bloomed yet, reset the consecutive counter.
        *   Return true if we can form at least `m` bouquets.
    *   Adjust `low` or `high` based on the check result to find the minimum possible day.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/1482/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(N \log (\max(\text{bloomDay})))$
    *   $N$ is the length of the `bloomDay` array.
    *   We perform binary search over the range of days, which takes $\log (\max(\text{bloomDay}))$ steps.
    *   In each step, we iterate through the array once, taking $O(N)$ time.

*   **Space Complexity:** $O(1)$
    *   We only use a constant amount of extra space for counters and pointers.