---
title: 1283. Find the Smallest Divisor Given a Threshold
tags:
  - Array
  - Binary Search
  - Medium
---

# 1283. Find the Smallest Divisor Given a Threshold

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/Shj_IYAHxXk){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/1283){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/solutions/7529439/smallest-divisor-binary-search-on-answer-eehx){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    Given an array of integers `nums` and an integer `threshold`, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the **smallest** divisor such that the result mentioned above is less than or equal to `threshold`.

    Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: $7/3 = 3$ and $10/2 = 5$).

    The test cases are generated so that there will be an answer.

### Examples

**Example 1:**
```text
Input: nums = [1,2,5,9], threshold = 6
Output: 5
Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 
```

**Example 2:**
```text
Input: nums = [44,22,33,11,1], threshold = 5
Output: 44
```

### Constraints
*   `1 <= nums.length <= 5 * 10^4`
*   `1 <= nums[i] <= 10^6`
*   `nums.length <= threshold <= 10^6`

## üß† Intuition

The problem asks for the *smallest* divisor that keeps the sum within a limit. A key observation is that as the **divisor increases**, the **sum decreases** (or stays the same). This monotonic property is a classic signal for **Binary Search on the Answer**.

Instead of trying every possible divisor, we can binary search through the range of possible divisors. For each divisor, we check if it's "valid" (sum $\le$ threshold).

## üí° Approach

1.  **Define the Search Space:**
    *   The smallest possible divisor is `1`.
    *   The largest necessary divisor is `max(nums)`, as any divisor larger than that will result in the same sum (each element becomes `1`, sum becomes `nums.length`).
2.  **Binary Search:**
    *   Calculate `mid = (low + high) / 2`.
    *   Check if `mid` is valid by summing `ceil(nums[i] / mid)` for all `i`.
    *   If `isValid(mid)` is true:
        *   `mid` might be the answer, but there could be a smaller one. Store `mid` in `result` and search the left half (`high = mid - 1`).
    *   Else:
        *   `mid` is too small, making the sum too large. Search the right half (`low = mid + 1`).
3.  **Ceil Division:** Calculate `ceil(a / b)` as `(a + b - 1) / b` to avoid floating point issues.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/1283/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(N \log(\max(\text{nums})))$
    *   The binary search takes $\log(\max(\text{nums}))$ steps.
    *   In each step, we iterate through the array of size $N$ to calculate the sum.

*   **Space Complexity:** $O(1)$
    *   We only use a few constant variables for the search.