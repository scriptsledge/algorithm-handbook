---
title: 0081. Search in Rotated Sorted Array II
tags:
  - Array
  - Binary Search
  - Medium
---

# 0081. Search in Rotated Sorted Array II

<div class="grid cards" markdown>

-   :material-youtube: **Watch the Solution**
    [Watch Video](https://youtube.com/shorts/HcrrB-Xtg8Q){ .md-button }

-   :material-github: **View on GitHub**
    [Source Code](https://github.com/scriptsledge/algorithm-handbook/tree/main/src/0081){ .md-button }

-   :simple-leetcode: **LeetCode Solution**
    [Read Post](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/7504755/c-on-worst-case-binary-search-81-search-qcaie){ .md-button }

</div>

## üìù Problem Description

!!! info "Problem Statement"
    There is an integer array `nums` sorted in non-decreasing order (not necessarily with distinct values).

    Before being passed to your function, `nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index 5 and become `[4,5,6,6,7,0,1,2,4,4]`.

    Given the array `nums` after the rotation and an integer `target`, return `true` if `target` is in `nums`, or `false` if it is not in `nums`.

    You must decrease the overall operation steps as much as possible.

### Examples

**Example 1:**

```
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
```

**Example 2:**

```
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
```

### Constraints

*   `1 <= nums.length <= 5000`
*   `-10^4 <= nums[i] <= 10^4`
*   `nums` is guaranteed to be rotated at some pivot.
*   `-10^4 <= target <= 10^4`

## üß† Intuition

The problem is a variation of binary search. Standard binary search relies on the array being sorted. Here, the array is rotated, but at least one half of the array (split by mid) will always be sorted. We can leverage this property. However, the presence of duplicates complicates things when `nums[left] == nums[mid] == nums[right]`, making it impossible to distinguish which half is sorted.

## üí° Approach

1.  **Initialize Pointers:** Set `left = 0` and `right = nums.size() - 1`.
2.  **Binary Search Loop:** Loop while `left <= right`.
    *   Calculate `mid`.
    *   If `nums[mid] == target`, return `true`.
    *   **Handle Duplicates:** If `nums[left] == nums[mid]` and `nums[mid] == nums[right]`, we cannot determine which side is sorted. In this case, simply shrink the search space by `left++` and `right--`. This is the only case that degrades time complexity to $O(N)$.
    *   **Left Half Sorted:** If `nums[left] <= nums[mid]`:
        *   Check if `target` is in the range `[nums[left], nums[mid])`. If so, search left (`right = mid - 1`).
        *   Otherwise, search right (`left = mid + 1`).
    *   **Right Half Sorted:** If `nums[left] > nums[mid]` (implied else):
        *   Check if `target` is in the range `(nums[mid], nums[right]]`. If so, search right (`left = mid + 1`).
        *   Otherwise, search left (`right = mid - 1`).
3.  **Return False:** If the loop finishes without finding the target.

## üíª Code

=== "C++"

    ```cpp
    --8<-- "src/0081/solution.cpp"
    ```

## üìä Complexity Analysis

*   **Time Complexity:** $O(\log N)$ on average, but $O(N)$ in the worst case where all elements are the same (e.g., `[1,1,1,1]` searching for `0`). The duplicate handling step `left++`, `right--` causes this degradation.
    
*   **Space Complexity:** $O(1)$ as we only use a constant amount of extra space for pointers.