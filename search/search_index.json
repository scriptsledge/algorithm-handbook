{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Algorithm Handbook \ud83d\udcd8","text":"<p>This is the definitive engineering reference by ScriptSledge, strictly documenting the analysis, implementation, and optimization of algorithms.</p>"},{"location":"#purpose","title":"\ud83c\udfaf Purpose","text":"<p>This handbook serves as a living repository of algorithmic patterns, designed for: *   Engineering Excellence: Writing clean, production-ready code. *   Deep Understanding: dissecting the why behind every solution. *   Knowledge Retention: A structured archive for future reference.</p>"},{"location":"#latest-additions","title":"\ud83d\udcda Latest Additions","text":"Problem Difficulty Tags 2563. Count the Number of Fair Pairs Medium <code>New</code> 0035. Search Insert Position Easy <code>New</code> 2176. Count Equal and Divisible Pairs in an Array Easy <code>Array</code> <code>Hash Table</code> 0704. Binary Search Easy <code>Binary Search</code> <code>Recursion</code> 0152. Maximum Product Subarray Medium <code>New</code> <p>...view all problems in the navigation menu.</p>"},{"location":"problems/0001/","title":"1. Two Sum","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution Read Post</p> </li> </ul>","tags":["Array","Hash Table","Easy"]},{"location":"problems/0001/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/0001/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [3,2,4], target = 6\nOutput: [1,2]\n</code></pre></p> <p>Example 3: <pre><code>Input: nums = [3,3], target = 6\nOutput: [0,1]\n</code></pre></p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/0001/#constraints","title":"Constraints","text":"<ul> <li><code>2 &lt;= nums.length &lt;= 10^4</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> <li><code>-10^9 &lt;= target &lt;= 10^9</code></li> <li>Only one valid answer exists.</li> </ul>","tags":["Array","Hash Table","Easy"]},{"location":"problems/0001/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The naive approach is to use nested loops to check every pair of numbers, which takes \\(O(N^2)\\) time.</p> <p>However, we can optimize this by using a Hash Table. As we iterate through the array, we check if the complement (i.e., <code>target - current_number</code>) exists in our table. If it does, we've found our pair. If not, we add the current number to the table and move on. This allows us to find the answer in a single pass.</p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/0001/#approach","title":"\ud83d\udca1 Approach","text":"<ol> <li>Create an empty hash map to store <code>value -&gt; index</code>.</li> <li>Iterate through the array <code>nums</code>:<ul> <li>Calculate <code>complement = target - nums[i]</code>.</li> <li>Check if <code>complement</code> exists in the hash map.</li> <li>If it exists, return <code>{hashMap[complement], i}</code>.</li> <li>If it doesn't exist, store <code>nums[i]</code> and its index <code>i</code> in the hash map.</li> </ul> </li> <li>Since the problem guarantees a solution, we will always find a match.</li> </ol>","tags":["Array","Hash Table","Easy"]},{"location":"problems/0001/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; hash_map;\n        for (int i = 0; i &lt; nums.size(); ++i) {\n            int complement = target - nums[i];\n            if (hash_map.find(complement) != hash_map.end()) {\n                return {hash_map[complement], i};\n            }\n            hash_map[nums[i]] = i;\n        }\n        return {};\n    }\n};\n\nvoid printVector(const vector&lt;int&gt;&amp; res) {\n    cout &lt;&lt; \"[\";\n    for (size_t i = 0; i &lt; res.size(); ++i) {\n        cout &lt;&lt; res[i];\n        if (i &lt; res.size() - 1) cout &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\" &lt;&lt; endl;\n}\n\nint main() {\n    Solution sol;\n\n    // Example 1\n    vector&lt;int&gt; nums1 = {2, 7, 11, 15};\n    int target1 = 9;\n    cout &lt;&lt; \"Test Case 1: \";\n    printVector(sol.twoSum(nums1, target1)); // Expected: [0,1]\n\n    // Example 2\n    vector&lt;int&gt; nums2 = {3, 2, 4};\n    int target2 = 6;\n    cout &lt;&lt; \"Test Case 2: \";\n    printVector(sol.twoSum(nums2, target2)); // Expected: [1,2]\n\n    // Example 3\n    vector&lt;int&gt; nums3 = {3, 3};\n    int target3 = 6;\n    cout &lt;&lt; \"Test Case 3: \";\n    printVector(sol.twoSum(nums3, target3)); // Expected: [0,1]\n\n    return 0;\n}\n</code></pre>","tags":["Array","Hash Table","Easy"]},{"location":"problems/0001/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N)\\)</p> <ul> <li>We traverse the array once. Hash map lookups and insertions are \\(O(1)\\) on average.</li> </ul> </li> <li> <p>Space Complexity: \\(O(N)\\)</p> <ul> <li>In the worst case, we store \\(N\\) elements in the hash map.</li> </ul> </li> </ul>","tags":["Array","Hash Table","Easy"]},{"location":"problems/0035/","title":"0035. Search Insert Position","text":"<ul> <li> <p> Watch the Solution Watch Video}</p> </li> <li> <p> View on GitHub Source Code}</p> </li> <li> <p> LeetCode Solution Read Post}</p> </li> </ul>","tags":["Binary Search","Array","Easy"]},{"location":"problems/0035/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p> <p>You must write an algorithm with \\(O(\\log n)\\) runtime complexity.</p>","tags":["Binary Search","Array","Easy"]},{"location":"problems/0035/#examples","title":"Examples","text":"<p>Example 1:</p> <p>Input: <code>nums = [1,3,5,6]</code>, <code>target = 5</code> Output: <code>2</code></p> <p>Example 2:</p> <p>Input: <code>nums = [1,3,5,6]</code>, <code>target = 2</code> Output: <code>1</code></p> <p>Example 3:</p> <p>Input: <code>nums = [1,3,5,6]</code>, <code>target = 7</code> Output: <code>4</code></p>","tags":["Binary Search","Array","Easy"]},{"location":"problems/0035/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^4</code></li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li> <li><code>nums</code> contains distinct values sorted in ascending order.</li> <li><code>-10^4 &lt;= target &lt;= 10^4</code></li> </ul>","tags":["Binary Search","Array","Easy"]},{"location":"problems/0035/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The array is already sorted, and the requirement for \\(O(\\log n)\\) complexity strongly suggests a Binary Search approach. We are looking for the smallest index <code>i</code> such that <code>nums[i] &gt;= target</code>. This index will be: 1. The index of the target if it exists. 2. The index where the target should be inserted if it doesn't exist.</p>","tags":["Binary Search","Array","Easy"]},{"location":"problems/0035/#approach","title":"\ud83d\udca1 Approach","text":"<p>We can implement this using a standard binary search template:</p> <ol> <li>Initialize: Set <code>low = 0</code> and <code>high = nums.size() - 1</code>. Initialize <code>pos = nums.size()</code> to cover the case where the target is larger than all elements in the array.</li> <li>Binary Search Loop:<ul> <li>Calculate <code>mid = low + (high - low) / 2</code>.</li> <li>If <code>nums[mid] &gt;= target</code>:<ul> <li>This <code>mid</code> index is a potential answer. Update <code>pos = mid</code>.</li> <li>Continue searching in the left half to see if there's an even smaller index that satisfies the condition: <code>high = mid - 1</code>.</li> </ul> </li> <li>Else (<code>nums[mid] &lt; target</code>):<ul> <li>The target must be further to the right: <code>low = mid + 1</code>.</li> </ul> </li> </ul> </li> <li>Return: After the loop, <code>pos</code> will hold the correct index.</li> </ol>","tags":["Binary Search","Array","Easy"]},{"location":"problems/0035/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {\n        int low = 0;\n        int high = nums.size() - 1;\n        int pos = nums.size();\n\n        while (low &lt;= high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] &gt;= target) {\n                pos = mid;\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n\n        return pos;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    vector&lt;int&gt; nums1 = {1, 3, 5, 6};\n    int target1 = 5;\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; (sol.searchInsert(nums1, target1) == 2 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    vector&lt;int&gt; nums2 = {1, 3, 5, 6};\n    int target2 = 2;\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; (sol.searchInsert(nums2, target2) == 1 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    vector&lt;int&gt; nums3 = {1, 3, 5, 6};\n    int target3 = 7;\n    cout &lt;&lt; \"Test Case 3: \" &lt;&lt; (sol.searchInsert(nums3, target3) == 4 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Binary Search","Array","Easy"]},{"location":"problems/0035/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(\\log N)\\)     We divide the search space by half in each iteration.</p> </li> <li> <p>Space Complexity: \\(O(1)\\)     We only use a constant amount of extra space for pointers.</p> </li> </ul>","tags":["Binary Search","Array","Easy"]},{"location":"problems/0053/","title":"53. Maximum Subarray","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution Read Post</p> </li> </ul>","tags":["Array","Divide and Conquer","Dynamic Programming","Medium"]},{"location":"problems/0053/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given an integer array <code>nums</code>, find the subarray with the largest sum, and return its sum.</p>","tags":["Array","Divide and Conquer","Dynamic Programming","Medium"]},{"location":"problems/0053/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n</code></pre></p> <p>Example 3: <pre><code>Input: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n</code></pre></p>","tags":["Array","Divide and Conquer","Dynamic Programming","Medium"]},{"location":"problems/0053/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code></li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li> </ul>","tags":["Array","Divide and Conquer","Dynamic Programming","Medium"]},{"location":"problems/0053/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The naive approach is to check every possible subarray (all possible start and end indices), calculate their sums, and find the maximum. However, with \\(N\\) up to \\(10^5\\), an \\(O(N^2)\\) solution will result in Time Limit Exceeded (TLE). We need a linear time \\(O(N)\\) solution.</p> <p>The key observation is: Should we extend the current subarray or start a new one? If the sum of the current subarray becomes negative, it essentially becomes a \"burden\" to any future element. No matter what the next number is, adding it to a negative sum will result in a smaller value than just starting fresh with the next number alone.</p>","tags":["Array","Divide and Conquer","Dynamic Programming","Medium"]},{"location":"problems/0053/#approach","title":"\ud83d\udca1 Approach","text":"<p>We use Kadane's Algorithm, which is a dynamic programming / greedy approach:</p> <ol> <li>Initialize <code>current_sum = 0</code> and <code>max_sum = nums[0]</code>.</li> <li>Iterate through each number <code>num</code> in <code>nums</code>.</li> <li>Add <code>num</code> to <code>current_sum</code>.</li> <li>Update <code>max_sum</code> if <code>current_sum</code> is greater.</li> <li>If <code>current_sum</code> becomes negative, reset it to <code>0</code>. This effectively discards the current subarray and starts a new one from the next element.</li> </ol>","tags":["Array","Divide and Conquer","Dynamic Programming","Medium"]},{"location":"problems/0053/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) {\n        int max_sum = nums[0];\n        int sum = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            sum += nums[i];\n            max_sum = max(max_sum, sum);\n            if (sum &lt; 0) {\n                sum = 0; // Reset sum when it becomes negative\n            }\n        }\n\n        return max_sum;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Test Case 1\n    vector&lt;int&gt; nums1 = {-2,1,-3,4,-1,2,1,-5,4};\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; (sol.maxSubArray(nums1) == 6 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Test Case 2\n    vector&lt;int&gt; nums2 = {1};\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; (sol.maxSubArray(nums2) == 1 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Test Case 3\n    vector&lt;int&gt; nums3 = {5,4,-1,7,8};\n    cout &lt;&lt; \"Test Case 3: \" &lt;&lt; (sol.maxSubArray(nums3) == 23 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Array","Divide and Conquer","Dynamic Programming","Medium"]},{"location":"problems/0053/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N)\\)</p> <ul> <li>We iterate through the array exactly once.</li> </ul> </li> <li> <p>Space Complexity: \\(O(1)\\)</p> <ul> <li>We only use two variables (<code>current_sum</code> and <code>max_sum</code>) for storage.</li> </ul> </li> </ul>","tags":["Array","Divide and Conquer","Dynamic Programming","Medium"]},{"location":"problems/0056/","title":"56. Merge Intervals","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution Read Post</p> </li> </ul>","tags":["Array","Sorting","Medium"]},{"location":"problems/0056/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given an array of <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p>","tags":["Array","Sorting","Medium"]},{"location":"problems/0056/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n</code></pre></p> <p>Example 2: <pre><code>Input: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n</code></pre></p> <p>Example 3: <pre><code>Input: intervals = [[4,7],[1,4]]\nOutput: [[1,7]]\nExplanation: Intervals [1,4] and [4,7] are considered overlapping.\n</code></pre></p>","tags":["Array","Sorting","Medium"]},{"location":"problems/0056/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= intervals.length &lt;= 10^4</code></li> <li><code>intervals[i].length == 2</code></li> <li><code>0 &lt;= start_i &lt;= end_i &lt;= 10^4</code></li> </ul>","tags":["Array","Sorting","Medium"]},{"location":"problems/0056/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The core difficulty is that intervals can come in any order. Comparing every interval with every other interval to check for overlaps would take \\(O(N^2)\\) time.</p> <p>However, if we sort the intervals by their start times, overlapping intervals will always be adjacent to each other. This allows us to process the intervals linearly. We can simply maintain a \"current\" interval and try to merge subsequent intervals into it.</p>","tags":["Array","Sorting","Medium"]},{"location":"problems/0056/#approach","title":"\ud83d\udca1 Approach","text":"<ol> <li>Sort: Sort the <code>intervals</code> array based on the start time of each interval.</li> <li>Initialize: Create a <code>result</code> list. Add the first interval to it as the \"current merged interval\".</li> <li>Iterate: Loop through the remaining intervals:<ul> <li>Let the last added interval in <code>result</code> be <code>[lastStart, lastEnd]</code>.</li> <li>Let the current interval being examined be <code>[currentStart, currentEnd]</code>.</li> <li>If Overlap (<code>currentStart &lt;= lastEnd</code>): The intervals merge. Update the end time of the last interval: <code>lastEnd = max(lastEnd, currentEnd)</code>.</li> <li>If No Overlap: The overlap chain is broken. Add <code>[currentStart, currentEnd]</code> to <code>result</code>.</li> </ul> </li> <li>Return: The <code>result</code> list now contains the merged intervals.</li> </ol>","tags":["Array","Sorting","Medium"]},{"location":"problems/0056/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        vector&lt;vector&lt;int&gt;&gt; result;\n        int size = intervals.size();\n\n        // Handle empty or single interval case\n        if (size &lt;= 1) {\n            return intervals;\n        }\n\n        // Sort intervals by start time\n        sort(intervals.begin(), intervals.end());\n\n        // Initialize with first interval\n        int lastStart = intervals[0][0];\n        int lastEnd = intervals[0][1];\n\n        for (int i = 1; i &lt; size; i++) {\n            int currentStart = intervals[i][0];\n            int currentEnd = intervals[i][1];\n\n            // If overlap, merge by updating the end time\n            if (currentStart &lt;= lastEnd) {\n                // Take the maximum end time\n                lastEnd = max(lastEnd, currentEnd);\n            } else {\n                // No overlap, add the previous merged interval to result\n                result.push_back({lastStart, lastEnd});\n\n                // Start a new merged interval\n                lastStart = currentStart;\n                lastEnd = currentEnd;\n            }\n        }\n\n        // Don't forget to add the last interval\n        result.push_back({lastStart, lastEnd});\n\n        return result;\n    }\n};\n\nvoid printIntervals(const vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    cout &lt;&lt; \"[\";\n    for (size_t i = 0; i &lt; intervals.size(); ++i) {\n        cout &lt;&lt; \"[\" &lt;&lt; intervals[i][0] &lt;&lt; \",\" &lt;&lt; intervals[i][1] &lt;&lt; \"]\";\n        if (i &lt; intervals.size() - 1) cout &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\" &lt;&lt; endl;\n}\n\nint main() {\n    Solution sol;\n\n    // Example 1\n    vector&lt;vector&lt;int&gt;&gt; intervals1 = {{1,3},{2,6},{8,10},{15,18}};\n    cout &lt;&lt; \"Test Case 1: \";\n    printIntervals(sol.merge(intervals1)); // Expected: [[1,6],[8,10],[15,18]]\n\n    // Example 2\n    vector&lt;vector&lt;int&gt;&gt; intervals2 = {{1,4},{4,5}};\n    cout &lt;&lt; \"Test Case 2: \";\n    printIntervals(sol.merge(intervals2)); // Expected: [[1,5]]\n\n    // Example 3\n    vector&lt;vector&lt;int&gt;&gt; intervals3 = {{4,7},{1,4}};\n    cout &lt;&lt; \"Test Case 3: \";\n    printIntervals(sol.merge(intervals3)); // Expected: [[1,7]]\n\n    return 0;\n}\n</code></pre>","tags":["Array","Sorting","Medium"]},{"location":"problems/0056/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N \\log N)\\)</p> <ul> <li>Sorting the intervals takes \\(O(N \\log N)\\).</li> <li>The linear pass takes \\(O(N)\\).</li> <li>Total complexity is dominated by sorting.</li> </ul> </li> <li> <p>Space Complexity: \\(O(N)\\)</p> <ul> <li>We create a <code>result</code> array which, in the worst case (no overlaps), stores all \\(N\\) intervals.</li> <li>If we disregard the output space, the sorting algorithm takes \\(O(\\log N)\\) or \\(O(N)\\) auxiliary space depending on implementation.</li> </ul> </li> </ul>","tags":["Array","Sorting","Medium"]},{"location":"problems/0088/","title":"88. Merge Sorted Array","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution Read Post</p> </li> </ul>","tags":["Array","Two Pointers","Sorting","Easy"]},{"location":"problems/0088/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in non-decreasing order, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p> <p>Merge <code>nums1</code> and <code>nums2</code> into a single array sorted in non-decreasing order.</p> <p>The final sorted array should not be returned by the function, but instead be stored inside the array <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>","tags":["Array","Two Pointers","Sorting","Easy"]},{"location":"problems/0088/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n</code></pre></p> <p>Example 2: <pre><code>Input: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n</code></pre></p> <p>Example 3: <pre><code>Input: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\n</code></pre></p>","tags":["Array","Two Pointers","Sorting","Easy"]},{"location":"problems/0088/#constraints","title":"Constraints","text":"<ul> <li><code>nums1.length == m + n</code></li> <li><code>nums2.length == n</code></li> <li><code>0 &lt;= m, n &lt;= 200</code></li> <li><code>1 &lt;= m + n &lt;= 200</code></li> <li><code>-10^9 &lt;= nums1[i], nums2[j] &lt;= 10^9</code></li> </ul>","tags":["Array","Two Pointers","Sorting","Easy"]},{"location":"problems/0088/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>We have two sorted arrays, and we want to merge them into the first one (<code>nums1</code>). <code>nums1</code> has extra zeros at the end to fit everything.</p> <p>If we start from the beginning (index 0), every time we want to insert an element from <code>nums2</code> into <code>nums1</code>, we would have to shift all subsequent elements of <code>nums1</code> to the right. This shifting is expensive (\\(O(N)\\) per insertion).</p> <p>However, we know exactly where the final sorted array ends (at index <code>m + n - 1</code>). Since the end of <code>nums1</code> is empty (buffer space), we can fill the array backwards. This ensures we never overwrite a value in <code>nums1</code> that we haven't processed yet.</p>","tags":["Array","Two Pointers","Sorting","Easy"]},{"location":"problems/0088/#approach","title":"\ud83d\udca1 Approach","text":"<ol> <li>Initialize three pointers:<ul> <li><code>p1</code> pointing to the last actual element in <code>nums1</code> (<code>m - 1</code>).</li> <li><code>p2</code> pointing to the last element in <code>nums2</code> (<code>n - 1</code>).</li> <li><code>p</code> pointing to the last position in the buffer (<code>m + n - 1</code>).</li> </ul> </li> <li>Iterate while both <code>p1</code> and <code>p2</code> are valid (\\(\\ge 0\\)):<ul> <li>Compare <code>nums1[p1]</code> and <code>nums2[p2]</code>.</li> <li>Place the larger value at <code>nums1[p]</code>.</li> <li>Decrement <code>p</code> and the pointer of the chosen element.</li> </ul> </li> <li>Edge Case: If <code>nums2</code> still has elements left after <code>p1</code> runs out (meaning <code>nums2</code> had smaller elements than everything in <code>nums1</code>), copy the remaining <code>nums2</code> elements into the front of <code>nums1</code>.</li> <li>If <code>p1</code> has elements left, we don't need to do anything because they are already in place.</li> </ol>","tags":["Array","Two Pointers","Sorting","Easy"]},{"location":"problems/0088/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n - 1;\n        int p = m + n - 1;\n\n        // Compare elements from the back and fill nums1 from the end\n        while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) {\n            if (nums1[p1] &gt; nums2[p2]) {\n                nums1[p--] = nums1[p1--];\n            } else {\n                nums1[p--] = nums2[p2--];\n            }\n        }\n\n        // If nums2 still has elements, copy them (nums1 elements are already in place)\n        while (p2 &gt;= 0) {\n            nums1[p--] = nums2[p2--];\n        }\n    }\n};\n\nvoid printVector(const vector&lt;int&gt;&amp; nums) {\n    cout &lt;&lt; \"[\";\n    for (size_t i = 0; i &lt; nums.size(); ++i) {\n        cout &lt;&lt; nums[i];\n        if (i &lt; nums.size() - 1) cout &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\" &lt;&lt; endl;\n}\n\nint main() {\n    Solution sol;\n\n    // Example 1\n    vector&lt;int&gt; nums1_1 = {1,2,3,0,0,0};\n    vector&lt;int&gt; nums2_1 = {2,5,6};\n    sol.merge(nums1_1, 3, nums2_1, 3);\n    cout &lt;&lt; \"Test Case 1: \";\n    printVector(nums1_1); // Expected: [1,2,2,3,5,6]\n\n    // Example 2\n    vector&lt;int&gt; nums1_2 = {1};\n    vector&lt;int&gt; nums2_2 = {};\n    sol.merge(nums1_2, 1, nums2_2, 0);\n    cout &lt;&lt; \"Test Case 2: \";\n    printVector(nums1_2); // Expected: [1]\n\n    // Example 3\n    vector&lt;int&gt; nums1_3 = {0};\n    vector&lt;int&gt; nums2_3 = {1};\n    sol.merge(nums1_3, 0, nums2_3, 1);\n    cout &lt;&lt; \"Test Case 3: \";\n    printVector(nums1_3); // Expected: [1]\n\n    return 0;\n}\n</code></pre>","tags":["Array","Two Pointers","Sorting","Easy"]},{"location":"problems/0088/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(M + N)\\)</p> <ul> <li>We traverse both arrays once from back to front.</li> </ul> </li> <li> <p>Space Complexity: \\(O(1)\\)</p> <ul> <li>We assume <code>nums1</code> has allocated space. We do not use any extra data structures.</li> </ul> </li> </ul>","tags":["Array","Two Pointers","Sorting","Easy"]},{"location":"problems/0152/","title":"152. Maximum Product Subarray","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution Read Post</p> </li> </ul>","tags":["Array","Dynamic Programming","Medium"]},{"location":"problems/0152/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given an integer array <code>nums</code>, find a subarray that has the largest product, and return the product.</p> <p>The test cases are generated so that the answer will fit in a 32-bit integer.</p>","tags":["Array","Dynamic Programming","Medium"]},{"location":"problems/0152/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n</code></pre></p>","tags":["Array","Dynamic Programming","Medium"]},{"location":"problems/0152/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li> <li><code>-10 &lt;= nums[i] &lt;= 10</code></li> <li>The product of any subarray of <code>nums</code> is guaranteed to fit in a 32-bit integer.</li> </ul>","tags":["Array","Dynamic Programming","Medium"]},{"location":"problems/0152/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The \"Maximum Product Subarray\" problem is similar to \"Maximum Sum Subarray\" (Kadane's Algorithm), but with a twist: negative numbers.</p> <ul> <li>If all numbers are positive, we simply multiply them all.</li> <li>If we have a negative number, it flips the sign of the current product. A large positive product becomes a large negative one (which is bad for the max), but a large negative product becomes a large positive one (which is good).</li> </ul> <p>This \"sign flipping\" means we can't simply discard negative results like we do in Kadane's algorithm.</p> <p>Key Observation: For any subarray not containing zero, the maximum product will always include either the first element or the last element. *   If there are an even number of negatives, the product of the whole array is positive and maximal. *   If there are an odd number of negatives, one negative number splits the array into two positive sections. We need to check the product \"prefix\" (before the splitter) and the \"suffix\" (after the splitter).</p>","tags":["Array","Dynamic Programming","Medium"]},{"location":"problems/0152/#approach","title":"\ud83d\udca1 Approach","text":"<p>We can solve this efficiently with a Two-Pass Scan:</p> <ol> <li>Forward Pass: Iterate from left to right, maintaining a running product <code>fwd</code>. If we encounter a zero, reset <code>fwd</code> to 1. Track the maximum value of <code>fwd</code>.</li> <li>Backward Pass: Iterate from right to left, maintaining a running product <code>bwd</code>. If we encounter a zero, reset <code>bwd</code> to 1. Track the maximum value of <code>bwd</code>.</li> </ol> <p>The global maximum of these two passes is our answer. This works because it effectively checks all prefixes and suffixes relative to the negative numbers and zeros.</p>","tags":["Array","Dynamic Programming","Medium"]},{"location":"problems/0152/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;climits&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProduct(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        int maxProd = INT_MIN;\n        int fwd = 1, bwd = 1;\n\n        for (int i = 0; i &lt; n; i++) {\n            fwd *= nums[i];\n            bwd *= nums[n - 1 - i];\n\n            maxProd = max({maxProd, fwd, bwd});\n\n            // If we encounter a zero, reset the running product to 1\n            // Zero essentially splits the array into subarrays\n            if (fwd == 0) fwd = 1;\n            if (bwd == 0) bwd = 1;\n        }\n\n        return maxProd;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Example 1\n    vector&lt;int&gt; nums1 = {2, 3, -2, 4};\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; (sol.maxProduct(nums1) == 6 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Example 2\n    vector&lt;int&gt; nums2 = {-2, 0, -1};\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; (sol.maxProduct(nums2) == 0 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Example 3: Edge case with single negative\n    vector&lt;int&gt; nums3 = {-2};\n    cout &lt;&lt; \"Test Case 3: \" &lt;&lt; (sol.maxProduct(nums3) == -2 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Example 4: Double negative\n    vector&lt;int&gt; nums4 = {-2, -3, 7};\n    cout &lt;&lt; \"Test Case 4: \" &lt;&lt; (sol.maxProduct(nums4) == 42 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Array","Dynamic Programming","Medium"]},{"location":"problems/0152/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N)\\)</p> <ul> <li>We iterate through the array once (calculating forward and backward products in the same loop).</li> </ul> </li> <li> <p>Space Complexity: \\(O(1)\\)</p> <ul> <li>We only use integer variables for tracking products.</li> </ul> </li> </ul>","tags":["Array","Dynamic Programming","Medium"]},{"location":"problems/0268/","title":"268. Missing Number","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution</p> <p>Read Post</p> </li> </ul>","tags":["Array","Math","Bit Manipulation","Easy"]},{"location":"problems/0268/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return the only number in the range that is missing from the array.</p>","tags":["Array","Math","Bit Manipulation","Easy"]},{"location":"problems/0268/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n</code></pre></p> <p>Example 3: <pre><code>Input: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n</code></pre></p>","tags":["Array","Math","Bit Manipulation","Easy"]},{"location":"problems/0268/#constraints","title":"Constraints","text":"<ul> <li><code>n == nums.length</code></li> <li><code>1 &lt;= n &lt;= 10^4</code></li> <li><code>0 &lt;= nums[i] &lt;= n</code></li> <li>All the numbers of <code>nums</code> are unique.</li> </ul>","tags":["Array","Math","Bit Manipulation","Easy"]},{"location":"problems/0268/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>We are looking for a single missing number in a continuous range from \\(0\\) to \\(n\\). </p> <p>If the array were complete, the sum of its elements would follow the arithmetic progression formula (Gauss Sum). By calculating this expected sum and subtracting the actual sum of the elements present in the array, the remainder must be the missing number. This is essentially a checksum approach.</p>","tags":["Array","Math","Bit Manipulation","Easy"]},{"location":"problems/0268/#approach","title":"\ud83d\udca1 Approach","text":"<ol> <li>Calculate Expected Sum: The sum of all integers from \\(0\\) to \\(n\\) is given by the formula:     $\\(\\sum_{i=0}^{n} i = \\frac{n(n+1)}{2}\\)$</li> <li>Calculate Actual Sum: Iterate through the input array <code>nums</code> and compute the sum of its elements.</li> <li>Find Missing Number:     $\\(\\text{Missing Number} = \\text{Expected Sum} - \\text{Actual Sum}\\)$</li> </ol>","tags":["Array","Math","Bit Manipulation","Easy"]},{"location":"problems/0268/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        // Gauss Summation Formula: Sum of first n numbers = n * (n + 1) / 2\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n\n        for (int num : nums) {\n            actualSum += num;\n        }\n\n        return expectedSum - actualSum;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Example 1\n    vector&lt;int&gt; nums1 = {3, 0, 1};\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; (sol.missingNumber(nums1) == 2 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Example 2\n    vector&lt;int&gt; nums2 = {0, 1};\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; (sol.missingNumber(nums2) == 2 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Example 3\n    vector&lt;int&gt; nums3 = {9, 6, 4, 2, 3, 5, 7, 0, 1};\n    cout &lt;&lt; \"Test Case 3: \" &lt;&lt; (sol.missingNumber(nums3) == 8 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Array","Math","Bit Manipulation","Easy"]},{"location":"problems/0268/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N)\\)</p> <ul> <li>We iterate through the array once to calculate the sum.</li> </ul> </li> <li> <p>Space Complexity: \\(O(1)\\)</p> <ul> <li>We only use a few integer variables for the sums, regardless of input size.</li> </ul> </li> </ul>","tags":["Array","Math","Bit Manipulation","Easy"]},{"location":"problems/0704/","title":"0704. Binary Search","text":"<ul> <li> <p> Watch the Solution Watch Video}</p> </li> <li> <p> View on GitHub Source Code}</p> </li> <li> <p> LeetCode Solution Read Post}</p> </li> </ul>","tags":["Easy","Binary Search","Recursion"]},{"location":"problems/0704/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p> <p>You must write an algorithm with \\(O(\\log n)\\) runtime complexity.</p>","tags":["Easy","Binary Search","Recursion"]},{"location":"problems/0704/#examples","title":"Examples","text":"<p>Example 1: Input: <code>nums = [-1,0,3,5,9,12]</code>, <code>target = 9</code> Output: <code>4</code> Explanation: <code>9</code> exists in <code>nums</code> and its index is <code>4</code></p> <p>Example 2: Input: <code>nums = [-1,0,3,5,9,12]</code>, <code>target = 2</code> Output: <code>-1</code> Explanation: <code>2</code> does not exist in <code>nums</code> so return <code>-1</code></p>","tags":["Easy","Binary Search","Recursion"]},{"location":"problems/0704/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^4</code></li> <li><code>-10^4 &lt; nums[i], target &lt; 10^4</code></li> <li>All the integers in <code>nums</code> are unique.</li> <li><code>nums</code> is sorted in ascending order.</li> </ul>","tags":["Easy","Binary Search","Recursion"]},{"location":"problems/0704/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>Binary search is the most efficient way to search in a sorted collection. By repeatedly halving the search space, we can find any element (or determine its absence) in logarithmic time.</p>","tags":["Easy","Binary Search","Recursion"]},{"location":"problems/0704/#approach","title":"\ud83d\udca1 Approach","text":"<ol> <li>Divide: Calculate the middle index <code>mid</code>. To prevent integer overflow, use <code>mid = low + (high - low) / 2</code>.</li> <li>Conquer:<ul> <li>If <code>nums[mid] == target</code>, we've found the target.</li> <li>If <code>nums[mid] &gt; target</code>, the target must be in the left half. Recurse on <code>[low, mid - 1]</code>.</li> <li>If <code>nums[mid] &lt; target</code>, the target must be in the right half. Recurse on <code>[mid + 1, high]</code>.</li> </ul> </li> <li>Base Case: If <code>low &gt; high</code>, the search range is empty, and the target is not in the array.</li> </ol>","tags":["Easy","Binary Search","Recursion"]},{"location":"problems/0704/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    int binary_search(vector&lt;int&gt;&amp; arr, int target, int low, int high) {\n        if (high &lt; low) {\n            return -1;\n        }\n        int mid = low + (high - low) / 2;\n        if (arr[mid] == target) return mid;\n        else if (arr[mid] &gt; target) {\n            return binary_search(arr, target, low, mid - 1);\n        }\n        return binary_search(arr, target, mid + 1, high);\n    }\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) {\n        int low = 0;\n        int high = nums.size() - 1;\n        return binary_search(nums, target, low, high);\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Test Case 1\n    vector&lt;int&gt; nums1 = {-1, 0, 3, 5, 9, 12};\n    int target1 = 9;\n    int result1 = sol.search(nums1, target1);\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; (result1 == 4 ? \"Passed\" : \"Failed\") &lt;&lt; \" (Expected 4, Got \" &lt;&lt; result1 &lt;&lt; \")\" &lt;&lt; endl;\n\n    // Test Case 2\n    vector&lt;int&gt; nums2 = {-1, 0, 3, 5, 9, 12};\n    int target2 = 2;\n    int result2 = sol.search(nums2, target2);\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; (result2 == -1 ? \"Passed\" : \"Failed\") &lt;&lt; \" (Expected -1, Got \" &lt;&lt; result2 &lt;&lt; \")\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Easy","Binary Search","Recursion"]},{"location":"problems/0704/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(\\log N)\\)     The search space is halved at each step, leading to a logarithmic number of comparisons.</p> </li> <li> <p>Space Complexity: \\(O(\\log N)\\)     Since we are using a recursive implementation, the recursion stack will consume \\(O(\\log N)\\) space. An iterative approach would reduce this to \\(O(1)\\).</p> </li> </ul>","tags":["Easy","Binary Search","Recursion"]},{"location":"problems/2149/","title":"2149. Rearrange Array Elements by Sign","text":"<ul> <li> <p> Watch the Solution Watch Short</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution My Post</p> </li> </ul>","tags":["Array","Two Pointers","Medium"]},{"location":"problems/2149/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>You are given a 0-indexed integer array <code>nums</code> of even length consisting of an equal number of positive and negative integers.</p> <p>You should return the array of <code>nums</code> such that the array follows the given conditions: 1. Every consecutive pair of integers have opposite signs. 2. For all integers with the same sign, the order in which they were present in <code>nums</code> is preserved. 3. The rearranged array begins with a positive integer.</p> <p>Return the modified array after rearranging the elements to satisfy the aforementioned conditions.</p>","tags":["Array","Two Pointers","Medium"]},{"location":"problems/2149/#examples","title":"Examples","text":"<p>Example 1:</p> <p>Input: <code>nums = [3,1,-2,-5,2,-4]</code> Output: <code>[3,-2,1,-5,2,-4]</code></p> <p>Example 2:</p> <p>Input: <code>nums = [-1,1]</code> Output: <code>[1,-1]</code></p>","tags":["Array","Two Pointers","Medium"]},{"location":"problems/2149/#constraints","title":"Constraints","text":"<ul> <li><code>2 &lt;= nums.length &lt;= 2 * 10^5</code></li> <li><code>nums.length</code> is even</li> <li><code>1 &lt;= |nums[i]| &lt;= 10^5</code></li> </ul>","tags":["Array","Two Pointers","Medium"]},{"location":"problems/2149/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The core constraint is preserving the relative order of positive and negative numbers separately. This immediately suggests that we can't swap elements in place arbitrarily. We need to \"pick\" the next positive number and the next negative number in their original sequences.</p> <p>Since the output must alternate <code>[+, -, +, -, ...]</code>, we know exactly where each number goes: *   Positive numbers go to indices <code>0, 2, 4, ...</code> *   Negative numbers go to indices <code>1, 3, 5, ...</code></p>","tags":["Array","Two Pointers","Medium"]},{"location":"problems/2149/#approach-two-pointers-optimal","title":"\ud83d\udca1 Approach: Two Pointers (Optimal)","text":"<p>We can achieve this in a single pass using two pointers and a result array.</p> <ol> <li>Initialize:<ul> <li><code>pos</code> pointer at <code>0</code> (first even index).</li> <li><code>neg</code> pointer at <code>1</code> (first odd index).</li> <li>A <code>result</code> vector of the same size as input.</li> </ul> </li> <li>Iterate: Loop through every number <code>x</code> in the input array.</li> <li>Place:<ul> <li>If <code>x &gt; 0</code>: Place <code>x</code> at <code>result[pos]</code>, then advance <code>pos</code> by 2.</li> <li>If <code>x &lt; 0</code>: Place <code>x</code> at <code>result[neg]</code>, then advance <code>neg</code> by 2.</li> </ul> </li> </ol>","tags":["Array","Two Pointers","Medium"]},{"location":"problems/2149/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector&lt;int&gt; rearrangeArray(vector&lt;int&gt;&amp; nums) {\n        int size = nums.size();\n        int positiveIndex = 0, negativeIndex = 1;\n        vector&lt;int&gt; result(nums);\n\n        for (int i = 0; i &lt; size; i++) {\n            if (nums[i] &lt; 0) {\n                result[negativeIndex] = nums[i];\n                negativeIndex += 2;\n            } else {\n                result[positiveIndex] = nums[i];\n                positiveIndex += 2;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; tests = {\n        {3,1,-2,-5,2,-4},\n        {-1,1}\n    };\n\n    for (auto&amp; nums : tests) {\n        cout &lt;&lt; \"Input: nums = [\";\n        for (size_t i = 0; i &lt; nums.size(); ++i) cout &lt;&lt; nums[i] &lt;&lt; (i &lt; nums.size() - 1 ? \",\" : \"\");\n        cout &lt;&lt; \"]\\n\";\n\n        vector&lt;int&gt; result = sol.rearrangeArray(nums);\n\n        cout &lt;&lt; \"Output: [\";\n        for (size_t i = 0; i &lt; result.size(); ++i) cout &lt;&lt; result[i] &lt;&lt; (i &lt; result.size() - 1 ? \",\" : \"\");\n        cout &lt;&lt; \"]\\n\\n\";\n    }\n    return 0;\n}\n</code></pre>","tags":["Array","Two Pointers","Medium"]},{"location":"problems/2149/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N)\\)     We iterate through the array exactly once. Each insertion is an \\(O(1)\\) operation.</p> </li> <li> <p>Space Complexity: \\(O(N)\\)     We use an extra array <code>result</code> of size \\(N\\) to store the rearranged elements.</p> </li> </ul>","tags":["Array","Two Pointers","Medium"]},{"location":"problems/2176/","title":"2176. Count Equal and Divisible Pairs in an Array","text":"<ul> <li> <p> Watch the Solution</p> <p>Watch Video}</p> </li> <li> <p> View on GitHub</p> <p>Source Code}</p> </li> <li> <p> LeetCode Solution</p> <p>Read Post}</p> </li> </ul>","tags":["Array","Hash Table","Easy"]},{"location":"problems/2176/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given a 0-indexed integer array <code>nums</code> of length <code>n</code> and an integer <code>k</code>, return the number of pairs <code>(i, j)</code> where <code>0 &lt;= i &lt; j &lt; n</code>, such that <code>nums[i] == nums[j]</code> and <code>(i * j)</code> is divisible by <code>k</code>.</p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/2176/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums = [3,1,2,2,2,1,3], k = 2\nOutput: 4\nExplanation:\nThere are 4 pairs that meet all the requirements:\n- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.\n- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.\n- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.\n- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [1,2,3,4], k = 1\nOutput: 0\nExplanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.\n</code></pre></p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/2176/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 100</code></li> <li><code>1 &lt;= nums[i], k &lt;= 100</code></li> </ul>","tags":["Array","Hash Table","Easy"]},{"location":"problems/2176/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The problem asks us to find pairs \\((i, j)\\) such that: 1. \\(i &lt; j\\) 2. \\(nums[i] = nums[j]\\) 3. \\((i \\times j) \\pmod k = 0\\)</p> <p>Since the constraints are very small (\\(N \\le 100\\)), a brute-force approach checking all pairs would be \\(O(N^2)\\), which is around \\(10,000\\) operations\u2014well within the time limit.</p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/2176/#approach","title":"\ud83d\udca1 Approach","text":"<ol> <li>Use a hash map to group indices by their corresponding values in the array.</li> <li>For each group of indices belonging to the same value:<ul> <li>Iterate through all pairs of indices \\((i, j)\\) in the group.</li> <li>Check if \\((i \\times j)\\) is divisible by \\(k\\).</li> <li>If yes, increment the count.</li> </ul> </li> </ol>","tags":["Array","Hash Table","Easy"]},{"location":"problems/2176/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPairs(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_map&lt;int, vector&lt;int&gt;&gt; indices;\n        int count = 0;\n\n        for (int i = 0; i &lt; nums.size(); i++) {\n            if (indices.count(nums[i])) {\n                for (int j : indices[nums[i]]) {\n                    if ((i * j) % k == 0)\n                        count++;\n                }\n            }\n            indices[nums[i]].push_back(i);\n        }\n\n        return count;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Example 1\n    vector&lt;int&gt; nums1 = {3, 1, 2, 2, 2, 1, 3};\n    int k1 = 2;\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; sol.countPairs(nums1, k1) &lt;&lt; \" (Expected: 4)\" &lt;&lt; endl;\n\n    // Example 2\n    vector&lt;int&gt; nums2 = {1, 2, 3, 4};\n    int k2 = 1;\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; sol.countPairs(nums2, k2) &lt;&lt; \" (Expected: 0)\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Array","Hash Table","Easy"]},{"location":"problems/2176/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li>Time Complexity: \\(O(N^2)\\) in the worst case (when all elements are the same), where \\(N\\) is the length of the array.</li> <li>Space Complexity: \\(O(N)\\) to store the indices in the hash map.</li> </ul>","tags":["Array","Hash Table","Easy"]},{"location":"problems/2563/","title":"2563. Count the Number of Fair Pairs","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution Read Post</p> </li> </ul>","tags":["Array","Two Pointers","Binary Search","Sorting","Medium"]},{"location":"problems/2563/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>Given a 0-indexed integer array <code>nums</code> of size <code>n</code> and two integers <code>lower</code> and <code>upper</code>, return the number of fair pairs.</p> <p>A pair <code>(i, j)</code> is fair if: - <code>0 &lt;= i &lt; j &lt; n</code>, and - <code>lower &lt;= nums[i] + nums[j] &lt;= upper</code></p>","tags":["Array","Two Pointers","Binary Search","Sorting","Medium"]},{"location":"problems/2563/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6\nOutput: 6\nExplanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [1,7,9,2,5], lower = 11, upper = 11\nOutput: 1\nExplanation: There is a single fair pair: (2,3).\n</code></pre></p>","tags":["Array","Two Pointers","Binary Search","Sorting","Medium"]},{"location":"problems/2563/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code></li> <li><code>nums.length == n</code></li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li> <li><code>-10^9 &lt;= lower &lt;= upper &lt;= 10^9</code></li> </ul>","tags":["Array","Two Pointers","Binary Search","Sorting","Medium"]},{"location":"problems/2563/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The problem asks us to count pairs <code>(i, j)</code> with <code>i &lt; j</code> whose sum falls within a specific range <code>[lower, upper]</code>. A brute-force approach would check all \\(O(N^2)\\) pairs, which is too slow for \\(N = 10^5\\).</p> <p>Since the order of elements in a pair doesn't matter for the sum, and the condition <code>i &lt; j</code> just means we need to pick two distinct elements, we can sort the array. Sorting allows us to use efficient search techniques like binary search or two pointers.</p>","tags":["Array","Two Pointers","Binary Search","Sorting","Medium"]},{"location":"problems/2563/#approach","title":"\ud83d\udca1 Approach","text":"<ol> <li>Sort the array <code>nums</code>.</li> <li>Iterate through each element <code>nums[i]</code> from <code>0</code> to <code>n-1</code>.</li> <li>For each <code>nums[i]</code>, we need to find the number of elements <code>nums[j]</code> where <code>j &gt; i</code> such that <code>lower &lt;= nums[i] + nums[j] &lt;= upper</code>.</li> <li>This is equivalent to finding <code>j &gt; i</code> such that <code>lower - nums[i] &lt;= nums[j] &lt;= upper - nums[i]</code>.</li> <li>We can use binary search to find the range of valid <code>j</code>'s:<ul> <li><code>lb = lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i])</code> gives the first index <code>j &gt; i</code> where <code>nums[j]</code> is at least <code>lower - nums[i]</code>.</li> <li><code>ub = upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i])</code> gives the first index <code>j &gt; i</code> where <code>nums[j]</code> is strictly greater than <code>upper - nums[i]</code>.</li> </ul> </li> <li>The number of valid <code>j</code>'s for a fixed <code>i</code> is <code>ub - lb</code>.</li> <li>Sum these counts for all <code>i</code>.</li> </ol>","tags":["Array","Two Pointers","Binary Search","Sorting","Medium"]},{"location":"problems/2563/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long countFairPairs(vector&lt;int&gt;&amp; nums, int lower, int upper) {\n        sort(nums.begin(), nums.end());\n        long long count = 0, n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            auto lb =\n                lower_bound(nums.begin() + i + 1, nums.end(), lower - nums[i]);\n            auto ub =\n                upper_bound(nums.begin() + i + 1, nums.end(), upper - nums[i]);\n            count += ub - lb;\n        }\n        return count;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Example 1\n    vector&lt;int&gt; nums1 = {0, 1, 7, 4, 4, 5};\n    int lower1 = 3, upper1 = 6;\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; (sol.countFairPairs(nums1, lower1, upper1) == 6 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Example 2\n    vector&lt;int&gt; nums2 = {1, 7, 9, 2, 5};\n    int lower2 = 11, upper2 = 11;\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; (sol.countFairPairs(nums2, lower2, upper2) == 1 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Array","Two Pointers","Binary Search","Sorting","Medium"]},{"location":"problems/2563/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N \\log N)\\)</p> <ul> <li>Sorting takes \\(O(N \\log N)\\).</li> <li>Iterating through the array takes \\(O(N)\\), and for each element, we perform two binary searches, each taking \\(O(\\log N)\\).</li> <li>Total: \\(O(N \\log N) + O(N \\log N) = O(N \\log N)\\).</li> </ul> </li> <li> <p>Space Complexity: \\(O(1)\\) (ignoring the space used by the sorting algorithm).</p> <ul> <li>We only use a few extra variables for counting and iterators.</li> </ul> </li> </ul>","tags":["Array","Two Pointers","Binary Search","Sorting","Medium"]},{"location":"problems/2874/","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution Read Post</p> </li> </ul>","tags":["Array","Prefix Sum","Medium"]},{"location":"problems/2874/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>You are given a 0-indexed integer array <code>nums</code>.</p> <p>Return the maximum value over all triplets of indices <code>(i, j, k)</code> such that <code>i &lt; j &lt; k</code>. If all such triplets have a negative value, return <code>0</code>.</p> <p>The value of a triplet of indices <code>(i, j, k)</code> is equal to <code>(nums[i] - nums[j]) * nums[k]</code>.</p>","tags":["Array","Prefix Sum","Medium"]},{"location":"problems/2874/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums = [12,6,1,2,7]\nOutput: 77\nExplanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.\nIt can be shown that there are no ordered triplets of indices with a value greater than 77.\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [1,10,3,4,19]\nOutput: 133\nExplanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.\nIt can be shown that there are no ordered triplets of indices with a value greater than 133.\n</code></pre></p> <p>Example 3: <pre><code>Input: nums = [1,2,3]\nOutput: 0\nExplanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.\n</code></pre></p>","tags":["Array","Prefix Sum","Medium"]},{"location":"problems/2874/#constraints","title":"Constraints","text":"<ul> <li><code>3 &lt;= nums.length &lt;= 10^5</code></li> <li><code>1 &lt;= nums[i] &lt;= 10^6</code></li> </ul>","tags":["Array","Prefix Sum","Medium"]},{"location":"problems/2874/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The problem asks us to maximize <code>(nums[i] - nums[j]) * nums[k]</code> with the constraint <code>i &lt; j &lt; k</code>. A naive approach would be to iterate through all possible triplets, which would take \\(O(N^3)\\) time. Given the constraint \\(N \\le 10^5\\), we need an \\(O(N)\\) approach.</p> <p>By fixing the middle element <code>nums[j]</code>, the problem reduces to finding the maximum <code>nums[i]</code> to the left of <code>j</code> and the maximum <code>nums[k]</code> to the right of <code>j</code>. If we can access these maximums in \\(O(1)\\) time, we can solve the entire problem in \\(O(N)\\).</p>","tags":["Array","Prefix Sum","Medium"]},{"location":"problems/2874/#approach","title":"\ud83d\udca1 Approach","text":"<p>We can use Prefix Max and Suffix Max arrays to store these maximum values.</p> <ol> <li>Prefix Max: Create an array <code>prefixMax</code> where <code>prefixMax[i]</code> is the maximum value in <code>nums[0...i]</code>.</li> <li>Suffix Max: Create an array <code>suffixMax</code> where <code>suffixMax[i]</code> is the maximum value in <code>nums[i...n-1]</code>.</li> <li>Iterate: For each index <code>j</code> from <code>1</code> to <code>n-2</code>:<ul> <li>The max value to the left is <code>prefixMax[j-1]</code>.</li> <li>The max value to the right is <code>suffixMax[j+1]</code>.</li> <li>Calculate the triplet value: <code>(prefixMax[j-1] - nums[j]) * suffixMax[j+1]</code>.</li> <li>Update the global maximum.</li> </ul> </li> </ol>","tags":["Array","Prefix Sum","Medium"]},{"location":"problems/2874/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long maximumTripletValue(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n &lt; 3) return 0;\n\n        vector&lt;int&gt; prefixMax(n, 0), suffixMax(n, 0);\n        prefixMax[0] = nums[0];\n\n        // Compute prefix max\n        for (int i = 1; i &lt; n; i++)\n            prefixMax[i] = max(prefixMax[i - 1], nums[i]);\n\n        // Compute suffix max\n        suffixMax[n - 1] = nums[n - 1];\n        for (int i = n - 2; i &gt;= 0; i--)\n            suffixMax[i] = max(suffixMax[i + 1], nums[i]);\n\n        long long maxValue = 0;\n\n        // Iterate through j to find max (prefixMax[i] - nums[j]) * suffixMax[k]\n        for (int j = 1; j &lt; n - 1; j++) {\n            long long left = prefixMax[j - 1] - (long long)nums[j];\n            long long right = suffixMax[j + 1];\n            maxValue = max(maxValue, left * right);\n        }\n\n        return maxValue;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Test Case 1\n    vector&lt;int&gt; nums1 = {12, 6, 1, 2, 7};\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; (sol.maximumTripletValue(nums1) == 77 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Test Case 2\n    vector&lt;int&gt; nums2 = {1, 10, 3, 4, 19};\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; (sol.maximumTripletValue(nums2) == 133 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Test Case 3\n    vector&lt;int&gt; nums3 = {1, 2, 3};\n    cout &lt;&lt; \"Test Case 3: \" &lt;&lt; (sol.maximumTripletValue(nums3) == 0 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Array","Prefix Sum","Medium"]},{"location":"problems/2874/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N)\\)</p> <ul> <li>We traverse the array to build <code>prefixMax</code> (\\(O(N)\\)).</li> <li>We traverse the array to build <code>suffixMax</code> (\\(O(N)\\)).</li> <li>We traverse the array to find the maximum triplet value (\\(O(N)\\)).</li> <li>Total time complexity is dominated by these linear passes.</li> </ul> </li> <li> <p>Space Complexity: \\(O(N)\\)</p> <ul> <li>We use two additional arrays <code>prefixMax</code> and <code>suffixMax</code> of size \\(N\\).</li> </ul> </li> </ul>","tags":["Array","Prefix Sum","Medium"]},{"location":"problems/3375/","title":"3375. Minimum Operations to Make Array Values Equal to K","text":"<ul> <li> <p> Watch the Solution Watch Video</p> </li> <li> <p> View on GitHub Source Code</p> </li> <li> <p> LeetCode Solution Read Post</p> </li> </ul>","tags":["Array","Hash Table","Easy"]},{"location":"problems/3375/#problem-description","title":"\ud83d\udcdd Problem Description","text":"<p>Problem Statement</p> <p>You are given an integer array <code>nums</code> and an integer <code>k</code>. An integer <code>h</code> is called valid if all values in the array that are strictly greater than <code>h</code> are identical. You are allowed to perform the following operation on <code>nums</code>: 1. Select an integer <code>h</code> that is valid for the current values in <code>nums</code>. 2. For each index <code>i</code> where <code>nums[i] &gt; h</code>, set <code>nums[i]</code> to <code>h</code>.</p> <p>Return the minimum number of operations required to make every element in <code>nums</code> equal to <code>k</code>. If it is impossible to make all elements equal to <code>k</code>, return <code>-1</code>.</p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/3375/#examples","title":"Examples","text":"<p>Example 1: <pre><code>Input: nums = [5,2,5,4,5], k = 2\nOutput: 2\nExplanation: The operations can be performed in order using valid integers 4 and then 2.\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [2,1,2], k = 2\nOutput: -1\nExplanation: It is impossible to make all the values equal to 2.\n</code></pre></p> <p>Example 3: <pre><code>Input: nums = [9,7,5,3], k = 1\nOutput: 4\n</code></pre></p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/3375/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 100</code></li> <li><code>1 &lt;= nums[i] &lt;= 100</code></li> <li><code>1 &lt;= k &lt;= 100</code></li> </ul>","tags":["Array","Hash Table","Easy"]},{"location":"problems/3375/#intuition","title":"\ud83e\udde0 Intuition","text":"<p>The operation allows us to take all elements greater than a value \\(h\\) and set them to \\(h\\), but only if those elements are all currently equal. This \"valid \\(h\\)\" constraint implies that we must process the unique values in the array in descending order. We \"sink\" the current maximum unique value down to the level of the next unique value.</p> <p>To reach the target value \\(k\\): 1. If any number is already less than \\(k\\), we can never reach \\(k\\) because operations only decrease values. 2. Every unique value in the array that is strictly greater than \\(k\\) must be reduced. Because of the \"valid \\(h\\)\" rule, each distinct value \\(&gt; k\\) requires exactly one operation to be brought down to the next level (and eventually to \\(k\\)).</p>","tags":["Array","Hash Table","Easy"]},{"location":"problems/3375/#approach","title":"\ud83d\udca1 Approach","text":"<ol> <li>Iterate through <code>nums</code>:<ul> <li>If any element <code>nums[i] &lt; k</code>, return <code>-1</code> immediately.</li> <li>If <code>nums[i] &gt; k</code>, add it to an <code>unordered_set</code>.</li> </ul> </li> <li>Count Unique Values: The number of operations needed is the number of distinct values we need to \"sink,\" which is the size of the set.</li> </ol>","tags":["Array","Hash Table","Easy"]},{"location":"problems/3375/#code","title":"\ud83d\udcbb Code","text":"C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minOperations(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_set&lt;int&gt; aboveK;\n\n        for (int n : nums) {\n            if (n &lt; k) return -1;\n            if (n &gt; k) aboveK.insert(n);\n        }\n\n        return aboveK.size();\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Example 1\n    vector&lt;int&gt; nums1 = {5, 2, 5, 4, 5};\n    int k1 = 2;\n    cout &lt;&lt; \"Test Case 1: \" &lt;&lt; (sol.minOperations(nums1, k1) == 2 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Example 2\n    vector&lt;int&gt; nums2 = {2, 1, 2};\n    int k2 = 2;\n    cout &lt;&lt; \"Test Case 2: \" &lt;&lt; (sol.minOperations(nums2, k2) == -1 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    // Example 3\n    vector&lt;int&gt; nums3 = {9, 7, 5, 3};\n    int k3 = 1;\n    cout &lt;&lt; \"Test Case 3: \" &lt;&lt; (sol.minOperations(nums3, k3) == 4 ? \"Passed\" : \"Failed\") &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>","tags":["Array","Hash Table","Easy"]},{"location":"problems/3375/#complexity-analysis","title":"\ud83d\udcca Complexity Analysis","text":"<ul> <li> <p>Time Complexity: \\(O(N)\\)</p> <ul> <li>We traverse the array once to check values and populate the set.</li> </ul> </li> <li> <p>Space Complexity: \\(O(N)\\)</p> <ul> <li>In the worst case where all elements are distinct and greater than \\(k\\), the set will store \\(N\\) elements.</li> </ul> </li> </ul>","tags":["Array","Hash Table","Easy"]}]}